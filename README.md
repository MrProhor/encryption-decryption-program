# Шифровальная программа
Программа, написанная на `java`, призванная для `шифровки/дешифровки` вводимого сообщения при помощи `ключа` методом `Вернама`

## Оглавление
1. [Меню и команды](#Меню_и_команды)
2. [Принцип шифровки и дешифровки](#Принцип_шифровки_и_дешифровки)
3. [Процесс шифровки и дешифровки](#Процесс_шифровки_и_дешифровки)
   1) [Процесс генерации ключа](#Процесс_генерации_ключа)

## Меню и команды
В начале работы Вам будет предложено ввести один из 4-х кодов в меню:
1) `\enc` — данная команда запускает процесс зашифровки
2) `\dec` — данная команда запускае процесс дешифровки. В этом процессе имеется команда `\rand`, которая создаёт случайный ключ
3) `\exit` — данная команда завершает работу программы

[Вернуться к оглавлению](#Оглавление)

## Принцип шифровки и дешифровки
Принцип шифровки и дешифровки основан на методе `шифра Вернама`.
Это простейший шифр на основе бинарной логики, который обладает абсолютной криптографической стойкостью. Без знания ключа, расшифровать его невозможно (доказано Клодом Шенноном).
Исходный алфавит — строчная и прописная латиница, строчная и прописная кирилица, цифры, пробел и символы `!"#$%&'()*+,-./:;<=>?@[\]^_{|}~`.

[Вернуться к оглавлению](#Оглавление)

## Процесс шифровки и дешифровки
Сообщение разбиваем на отдельные символы и каждый символ представляем в бинарном виде. Далее используем `"Исключающее ИЛИ" (XOR)`. 

XOR принимает сигналы (0 или 1 каждый), проводит над ними логическую операцию и выдает один сигнал, исходя из входных значений.
Если все сигналы равны между собой (0-0 или 1-1 или 0-0-0 и т.д.), то на выходе получаем 0.
Если сигналы не равны (0-1 или 1-0 или 1-0-0 и т.д.), то на выходе получаем 1.

Теперь для шифровки сообщения, вводим сам текст для шифровки и ключ **такой же длины**. Переведем каждую букву в ее бинарный код и выполним действия в соответствии с ключом

```
Например:
сообщение: Энакин
ключ: Вейдер
```

Переведем их в бинарный код и выполним XOR:

```
10000101101 10000111101 10000110000 10000111010 10000111000 10000111101 — Энекин
10000010010 10000110101 10000111001 10000110100 10000110101 10001000000 — Вейдер
_______________________________________________________________________
00000111111 00000001000 00000001001 00000001110 00000001101 00001111101 — ?}
```

Заметим, что для удобства и правмльности представления мы будем добавлять незначащие нули в начале бинарного кода символа, пока не получим равное число нулей и единиц.

В данном конкретном примере на месте результирующих символов мы увидим неотображаемые символы и некоторыевидимые знаки, ведь часть все символов попала в первые 32 служебных символа. Однако, если перевести полученный результат в числа, то получим следующую картину:
```
63 8 9 14 13 125
```
Свиду — это обычный набор чисел, но мы то знаем правду)

Чтобы избежать недопонимания при шифровке/дешифровке, зашифрованнай результат будет представляться в числах.

[Вернуться к оглавлению](#Оглавление)

### Процесс генерации ключа
Ключ генерируется автоматически, длиной, равной заданному для зашифровки сообщению. 
Все символы выводятся случайно с помощью метода `Math.random() * 10000`, который возвращает псевдослучайное число в промежутке `(0;1)` умноженное на 1000, таким образом, при округлении мы можем получить целые числа в промежутке `от 0, до 9999`.
Получаемое, уже целое число, сравнивается с промежутками `от 32 до 126` и `от 1040 до 1105`, на которых определяются `строчные и прописные буквы латиницы, цифры, пробел и символы ``!"#$%&'()*+,-./:;<=>?@[\]^_{|}~`, а также `строчные и прописные буквы кирилицы` соответственно. Если псевдослучайное число входит в один из этих промежутков, то оно входит в ключ, иначе перебор чисел продолжается.

[Вернуться к оглавлению](#Оглавление)
